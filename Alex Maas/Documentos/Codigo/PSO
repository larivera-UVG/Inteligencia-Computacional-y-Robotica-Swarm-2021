/*  Implementacion del  PSO para su uso en Raspberry 
Alex Maas #17146  */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <ctype.h>

#define MSG_SIZE 40 // message size
#define IP_LENGTH 15

#define TUC_CONTROLLER 0
#define PID_CONTROLLER 0
#define NKC_CONTROLLER_1 0
#define NKC_CONTROLLER_2 0
#define NKC_CONTROLLER_3 0
#define LQR_CONTROLLER 0
#define LQI_CONTROLLER 1

// Parametro de orientacion
#define USE_BEARING 0

// Variables globales
#define TIME_STEP 32
#define MAX_CHANGE 1
#define PUERTO 2000
#define COMMUNICATION_CHANNEL 1

// Fitness Funcion
#define funcion_costo 0
#define TIME_DELTA 0.032

// Parametro actualizar PSO
#define PSO_STEP 1
#define USE_STANDART_PSO 1

// Parametro de Inercia  (0-cte, 1-linear, 2-chaotic, 3-random, 4-exponential)
#define INERTIA_TYPE 1

// Parametros PSO
#define CONSTRICTION_FACTOR 0.8
#define COGNITIVE_WEIGTH 2
#define SOCIAL_WEIGTH 10

// Parametros PID
#define K_PROPORTIONAL 0.5
#define K_INTEGRAL 0.1
#define K_DERIVATIVE 10

// Parametros NKC
#define K_DISTANCE 0.1
#define K_ALPHA 0.5
#define K_BETA 0.05

static const double *posicion_robot; //falta sensor
static const double rad;

// Nuevas posiciones del robot
static double new_position[] = {0, 0};
static double new_velocity[] = {0, 0};
static double theta_g = 0; // Orientacion del robot

// Posiciones actuales del robot
static double actual_position[] = {0, 0};
static double old_velocity[] = {0, 0};
static double fitness_actual = 0;
static double theta_o = 0; // Orientacion del robot

// Posicion Local
static double best_local[] = {0, 0};
static double fitness_local = 0;

// Posicion Global
static double best_global[] = {0, 0};
static double fitness_global = 0;

// Recepcion de datos de otros robots
static double recepcion[2];


// Parametros PSO
static double epsilon = CONSTRICTION_FACTOR;
static double C1 = COGNITIVE_WEIGTH;
static double C2 = SOCIAL_WEIGTH;
static double w = 0;
static double rho1 = 0;
static double rho2 = 0;
static double scaler = TIME_DELTA;

// Calculo de Inercia PSO
static double w_min = 0.5;
static double w_max = 1;
static int Maxiter = 10000;
static int iter = 0;

// Variables del controlador PSO
static double KP = K_PROPORTIONAL;
static double KI = K_INTEGRAL;
static double KD = K_DERIVATIVE;
static double e_old = 0;
static double E_old = 0;
static double e_o = 0;
static double E_o = 0;
static double e_D = 0;

// Variables del controlador NKC
static double alpha = 0;
static double beta = 0;
static double rho_p = 0;
static double K_RHO = K_DISTANCE;
static double K_A = K_ALPHA;
static double K_B = -K_BETA;

// Variables del conntrolador LQI
static double delta_t = TIME_DELTA;
static double XI_X = 0; // Error integrativo de X
static double XI_Y = 0; // Error integrativo de Y

// Error de posicion entre robot-meta
static double e_x = 0; // Diferencial de posicion horizontal
static double e_y = 0; // Diferencia de posicion vertical
static double e_p = 0; // Distacia euclidiana entre robot y meta

// Variable zero
static int zero = 0;
static int numero_iter = 0;

//Inicializacion
int estado = 0;

// Variable de recibir
char buffer_recibir[MSG_SIZE]; // to store received messages or messages to be sent.
char *token;

// Numeros aleatorios
double printRandoms(int lower, int upper, int count)
{
    int i;
    double num = 0;
    for (i = 0; i < count; i++)
    {
        num = (rand() % (upper - lower + 1)) + lower;
    }
    return num;
}

// Numeros random
double randfrac(void)
{
    double res = (rand() % RAND_MAX) / (double)RAND_MAX;
    return res;
}
/*
// Funciones costo
double funcion(double x, double y){
    double f=0;
    if (funcion_costo==0){
        f=pow(x,2)+pow(y,2);                        // Sphere
    }else if (funcion_costo==1){
        f=pow(1-x,2)+100*pow(y-pow(x,2),2);         // Rosenbrock
    }else if (funcion_costo==2){
        f=pow(x+2*y-7,2)+pow(2*x+y-5,2);            // Booth
    }else if(funcion_costo==3){
        f=pow(x*x+y-11,2)+pow(x+y*y-7,2);           // Himmelblau
    }
    return f;
}*/

//------------------------------Comunicacion -------------------------------
void error(const char *msg)
{
    perror(msg);
    exit(0);
}
//-------------------Hilo para recibir--------------------------------------
// Receiving thr: constantly waits for messages. Whatever is received is displayed.
void *receiving(void *ptr)
{
    int *sock, n;
    int i = 0;
    sock = (int *)ptr;                                // socket identifier
    unsigned int length = sizeof(struct sockaddr_in); // size of structure
    struct sockaddr_in from;

    while (1)
    {
        memset(buffer_recibir, 0, MSG_SIZE); // "limpia" el buffer
        // receive message
        n = recvfrom(*sock, buffer_recibir, MSG_SIZE, 0, (struct sockaddr *)&from, &length);
        if (n < 0)
        {
            error("Error: recvfrom");
        }
        i = 0;
        printf("%s \n ", buffer_recibir);
        // descomponer buffer_recibir, strtok
        token = strtok(buffer_recibir, ",");
        recepcion[i] = atof(token);

        while ((token = strtok(NULL, ",")) != NULL)
        {
            i++;
            recepcion[i] = atof(token);
        }
        // Actualizar global best
        printf("%f, %f \n ", recepcion[2], fitness_global);
        if (recepcion[2] < fitness_global){ //Local< Global, asigna el valor local al global
            //Actualizr global best (si local es mejor que global)
            printf("Global actualizado.\n");
            best_global[0] = recepcion[0];
            best_global[1] = recepcion[1];
            fitness_global = recepcion[2];
        }
        else
        {
            printf("No se actualiza el Global.\n");
        }
    }
    pthread_exit(0);
}
//------------------------------------------------------------------------------------------
void *gps(void){
    // Open the communication
    gps_init();
    loc_t data;
    while (1) {
        gps_location(&data);
        // Visualizacion de la informacion
        printf("%lf %lf\n", data.latitude, data.longitude);
        posicion_robot[2]= data.longitude;
        posicion_robot[0]= data.latitude;
        rad = data.course;
    }
}
//------------------------------------------------------------------------------------------
// Main function
int main(int argc, char *argv[])
{
    //------------------------------Comunicacion -------------------------------
    int sock, n;
    unsigned int length = sizeof(struct sockaddr_in); // size of structure
    char buffer_enviar[MSG_SIZE];                     // to store received messages or messages to be sent.
    struct sockaddr_in anybody;                       // for the socket configuration
    int boolval = 1;                                  // for a socket option
    pthread_t thread_rec;                             // thread variable
    char IP_broadcast[IP_LENGTH];                     // para la dirección de broadcast
    FILE *file;

    strcpy(IP_broadcast, "10.0.0.255"); // Puede que se deba cambiar. Revisar ifconfig

    printf("La dirección de broadcast es: %s\n\n", IP_broadcast);

    anybody.sin_family = AF_INET;                // symbol constant for Internet domain
    anybody.sin_port = htons(PUERTO);            // port field
    anybody.sin_addr.s_addr = htonl(INADDR_ANY); // para recibir de cualquiera

    sock = socket(AF_INET, SOCK_DGRAM, 0); // Creates socket. Connectionless.
    if (sock < 0)
        error("Error: socket");

    // Sin el bind, no se reciben los mensajes
    if (bind(sock, (struct sockaddr *)&anybody, sizeof(struct sockaddr_in)) < 0)
    {
        printf("Error binding socket.\n");
        exit(-1);
    }

    // change socket permissions to allow broadcast
    if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &boolval, sizeof(boolval)) < 0)
    {
        printf("Error setting socket options.\n");
        exit(-1);
    }

    anybody.sin_addr.s_addr = inet_addr(IP_broadcast); // broadcast address

    // Se creae el hilo de recepción.
    pthread_create(&thread_rec, NULL, receiving, (void *)&sock); // for receiving

    printf("Este programa despliega lo que sea que reciba.\n");
    printf("También transmite lo que el usuario ingrese, max. 40 caracteres. (! para salir):\n");
    do
    {
        memset(buffer_enviar, 0, MSG_SIZE); // "limpia" el buffer
                                            //fgets(buffer_enviar,MSG_SIZE-1,stdin); // MSG_SIZE-1 'cause a null character is added
        sleep(5);
        sprintf(buffer_enviar, "%f,%f,%f", best_local[0], best_local[1], fitness_local);
        if (buffer_enviar[0] != '!')
        {
            // send message to anyone there...
            n = sendto(sock, buffer_enviar, strlen(buffer_enviar), 0,
                       (const struct sockaddr *)&anybody, length);
            if (n < 0)
                error("Error: sendto");
        }
    } while (buffer_enviar[0] != '!');

    close(sock); // close socket.

    //------------------------------------------------------------------------------------------
    // Obtener posicion del robot

    // Main loop
    while (TIME_STEP != -1)
    {
        numero_iter++;
        // Configuracion de valores iniciales del PSO
        if (estado == 0)
        {
            //posicion_robot = 0;                     //GPS
            actual_position[0] = posicion_robot[2]; // coordenada X
            actual_position[1] = posicion_robot[0]; // coordenada Y
            best_local[0] = actual_position[0];
            best_local[1] = actual_position[1];
            best_global[0] = actual_position[0];
            best_global[1] = actual_position[1];

            // Calcular  Fitness valor
            fitness_local = funcion(actual_position[0], actual_position[1]);
            fitness_global = funcion(actual_position[0], actual_position[1]);
            estado = 1;
        }

        //------------------Obtener posicion y orientacion del robot-------------------------------
        posicion_robot = 0; GPS

        //const double north = [0,0];   //GPS angulo
        //double rad = atan2(north[0],north[2]);

        // Orientacion como angulo de brujula
        double bearing = ((rad) / M_PI) * 180.0;
        theta_o = bearing + 180;

        // Orientacion como angulo normal
        double bearing2 = ((rad) / M_PI) * 180.0;

        // Convertir numero negativo entre 0 y 360
        if (bearing2 < 0)
        {
            bearing2 = 360 + bearing2;  // asegurar angulp entre 0 y 2pi
        }

        double theta_o2 = 270 - bearing2;
        if (theta_o2 < 0)
        {
            theta_o2 = theta_o2 + 360;  // asegurar angulp entre 0 y 2pi
        }

        if (USE_BEARING == 0)
        {
            theta_o = theta_o2;
        }
        //--------------------------- Actualizacion de global y local best-------------------------------

        // Calcular fitness valor de posicion actual
        actual_position[0] = posicion_robot[2];
        actual_position[1] = posicion_robot[0];
        fitness_actual = funcion(actual_position[0], actual_position[1]);

        // Actualizar local best si posicion actual  posee una mejor fitness valor
        if (fitness_actual < fitness_local)
        {
            best_local[0] = actual_position[0];
            best_local[1] = actual_position[1];
            fitness_local = fitness_actual;
        }
        // Actualizar global best (propio no el recibido-enviado)
        if (fitness_local < fitness_global)
        {
            best_global[0] = best_local[0];
            best_global[1] = best_local[1];
            fitness_global = fitness_local;
        }
        // ----------------------- MPSO Algorithm --------------

        // Parametros de uniformidad
        rho1 = randfrac();
        rho2 = randfrac();

        // Calculo de Inercia invariante en el tiempo
        if (INERTIA_TYPE == 0)
        {
            w = 0.8;
        }
        else if (INERTIA_TYPE == 1)
        {
            w = w_max - (w_max - w_min) * iter / Maxiter;
        }
        else if (INERTIA_TYPE == 2)
        {
            double zi = 0.2;
            double zii = 4 * zi * (1 - zi);
            w = (w_max - w_min) * ((Maxiter - iter) / Maxiter) * w_max * zii;
            iter = iter + 1;
        }
        else if (INERTIA_TYPE == 3)
        {
            w = 0.5 + printRandoms(0, 1, 1) / 2;
        }
        else if (INERTIA_TYPE == 4)
        {
            w = w_min + (w_max - w_min) * exp((-1 * iter) / (Maxiter / 10));
        }

        // Configuracion estandar del PSO
        if (USE_STANDART_PSO == 1)
        {
            C1 = 2.05;
            C2 = 2.05;

            // Parametro de Constriccion
            double phi_T = C1 + C2;
            epsilon = 2.0 / fabs(2 - phi_T - sqrt(pow(phi_T, 2) - 4 * phi_T));

            // Configuracion de PSO Velocity Scaler
            scaler = 0.25;
            if (TUC_CONTROLLER == 1)
            {
                scaler = 0.625;
            }
            if (PID_CONTROLLER == 1)
            {
                scaler = 7.8125;
            }
        }

        // Ecuaciones de velocidad PSO para calcular una nueva velocidad
        old_velocity[0] = new_velocity[0];
        old_velocity[0] = new_velocity[0];
        new_velocity[0] = epsilon * (w * old_velocity[0] + C1 * rho1 * (best_local[0] - actual_position[0]) + C2 * rho2 * (best_global[0] - actual_position[0]));
        new_velocity[1] = epsilon * (w * old_velocity[1] + C2 * rho2 * (best_local[1] - actual_position[1]) + C2 * rho2 * (best_global[1] - actual_position[1]));

        // Ecuacion de posicion PSO para calcular nueva posicion
        if (numero_iter % PSO_STEP == 0 || numero_iter == 1)
        {
            new_position[0] = actual_position[0] + new_velocity[0] * scaler;
            new_position[1] = actual_position[1] + new_velocity[1] * scaler;
        }
        // ------------------ Variables de Controladores ----------------------

        // Inicializacion  de velocidad angular y lineal
        double v = 0;
        double w = 0;

        // Calculo de error de distancias
        e_x = new_position[0] - actual_position[0];
        e_y = new_position[1] - actual_position[1];
        e_p = sqrt(pow(e_y, 2) + pow(e_x, 2));

        // -------------------- Control de ecuaciones cinematicas ---------------

        // Constante de ponderacion
        double K = 3.12 * (1 - exp(-2 * pow(e_p, 1))) / e_p;

        // -------------------- Control PID de velocidad angular ---------------
        if (USE_BEARING == 0)
        {
            // Angulo de meta calculado en orientacion normal desde la horizontal
            theta_g = atan2(new_position[1] - actual_position[1], new_position[0] - actual_position[0]);
        }
        else
        {
            // Angulo de meta calculado en orientacion de brujula desde la vertical
            theta_g = atan2(new_position[0] - actual_position[0], new_position[1] - actual_position[1]);
        }

        // Mnatener angulo de orinetacion entre -pi y pi
        double orientation_angle = 0;
        if (theta_o > 180)
        {
            orientation_angle = theta_o - 360;
        }
        else
        {
            orientation_angle = theta_o;
        }

        // error de distancia angular
        e_o = atan2(sin(theta_g - (orientation_angle * M_PI / 180)), cos(theta_g - (orientation_angle * M_PI / 180)));

        // PID velocidad angular
        e_D = e_o - e_old;
        E_o = E_old + e_o;
        if (PID_CONTROLLER)
        {
            w = KP * e_o + KI * E_o + KD * e_D;
        }

        // ----------- Controles no lineales de robot --------------------------------

        rho_p = e_p;

        // LImitar angulo entre eje frontal del robot
        alpha = -(theta_o * M_PI / 180) + atan2(e_y, e_x);
        if (alpha < -M_PI)
        {
            alpha = alpha + (2 * M_PI);
        }
        else if (alpha > M_PI)
        {
            alpha = alpha - (2 * M_PI);
        }

        // Limitar angulo de orientacion de meta entre -pi y pi
        beta = -(theta_o * M_PI / 180) - alpha;
        if (beta < -M_PI)
        {
            beta = beta + (2 * M_PI);
        }
        else if (beta > M_PI)
        {
            beta = beta - (2 * M_PI);
        }

        // Controlador simple de pose de robot
        if (NKC_CONTROLLER_1)
        {
            v = K_RHO * rho_p;
            w = K_A * alpha + K_B * beta;
            if ((alpha <= -M_PI / 2) || (alpha > M_PI / 2))
            {
                v = -v;
            }
        }

        // Controlador Lyapunov de pose de robot
        if (NKC_CONTROLLER_2)
        {
            v = K_RHO * rho_p * cos(alpha);
            w = K_RHO * sin(alpha) * cos(alpha) + K_A * alpha;
            if ((alpha <= -M_PI / 2) || (alpha > M_PI / 2))
            {
                v = -v;
            }
        }

        // Controlador Closed-loop steering
        if (NKC_CONTROLLER_3)
        {
            double k_1 = 1;
            double k_2 = 10;
            w = -(2.0 / 5) * (v / rho_p) * (k_2 * (-alpha - atan(-k_1 * beta)) + (1 + k_1 / (1 + pow(k_1 * beta, 2))) * sin(-alpha));
        }

        // Controlador LQR
        if (LQR_CONTROLLER)
        {
            double K_x = 0.1;
            double K_y = 0.1;
            double u_1 = K_x * e_x;
            double u_2 = K_y * e_y;

            u_1 = -K_x * (actual_position[0] - new_position[0]);
            u_2 = -K_y * (actual_position[1] - new_position[1]);

            v = u_1 * cos((theta_o)*M_PI / 180) + u_2 * sin((theta_o)*M_PI / 180);
            w = (-u_1 * sin((theta_o)*M_PI / 180) + u_2 * cos((theta_o)*M_PI / 180));
            // w = (-u_1*sin((theta_o)*M_PI/180) + u_2*cos((theta_o)*M_PI/180))/l; al tener llantas
        }

        // Controlador LQI
        if (LQI_CONTROLLER)
        {
            double Klqr_x = 0.2127;
            double Klqr_y = 0.2127;
            double Klqi_x = -0.0224;
            double Klqi_y = -0.0224;

            // Damperos control LQI
            double bv_p = 0.95;
            double bv_i = 0.01;

            // Controlador LQI
            double u_1 = -Klqr_x * (1 - bv_p) * (actual_position[0] - new_position[0]) - Klqi_x * XI_X;
            double u_2 = -Klqr_y * (1 - bv_p) * (actual_position[1] - new_position[1]) - Klqi_y * XI_Y;

            XI_X = XI_X + (best_global[0] - actual_position[0]) * delta_t;
            XI_Y = XI_Y + (best_global[1] - actual_position[1]) * delta_t;

            XI_X = (1 - bv_i) * XI_X;
            XI_Y = (1 - bv_i) * XI_Y;
            // mapeo de velocidades LQI a velocidades de robot diferencial
            v = u_1 * cos((theta_o)*M_PI / 180) + u_2 * sin((theta_o)*M_PI / 180);
            w = (-u_1 * sin((theta_o)*M_PI / 180) + u_2 * cos((theta_o)*M_PI / 180));
            // w = (-u_1*sin((theta_o)*M_PI/180) + u_2*cos((theta_o)*M_PI/180))/l; al tener llantas
        }
        //fprintf(fp, "Z,%s,%lf,%lf,%lf,%lf,\r\n",rho_p, alpha, XI_X, XI_Y);

        // Terminacion del movimiento cerca de la meta
        if (fabs(e_p) < 0.005)
        {
            v = 0;
            w = 0;
        }

        // ---------------- Transformacion de velocidades con modelo diferencial
    }
    return 0;
}

