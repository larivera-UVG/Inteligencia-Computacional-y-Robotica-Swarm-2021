import random as rd
import numpy as np
import matplotlib.pyplot as plt
import math
rd.seed(12)

#Calculo de Inercia PSO
w_min = 0.5
w_max = 1
Maxiter = 10000
iter = 0

Inertia_type = 2
if (Inertia_type== 0):
    W = 0.8
elif (Inertia_type == 1):
    W = w_max - (w_max - w_min) * iter / Maxiter
elif (Inertia_type == 2):
    zi = 0.2
    zii = 4 * zi * (1 - zi)
    W = (w_max - w_min) * ((Maxiter - iter) / Maxiter) * w_max * zii
    iter = iter + 1
elif (Inertia_type == 3):
    W = w_min + (w_max - w_min) * math.exp((-1 * iter) / (Maxiter / 10))

#W = 0.8
c1 = 2
c2 = 10

n_iterations = 50
n_particles = 100
target_error = 1e-6
dt = 0.1

class Particula():
    def __init__(self):
        x = (-1) ** bool(rd.getrandbits(1))*rd.random()*5
        y = (-1) ** bool(rd.getrandbits(1))*rd.random()*5
        self.position = np.array([x,y])
        self.pBest_position = self.position
        self.pBest_value = float('inf')
        self.velocity = np.array([0,0])

    def update(self):
        self.position = self.position + self.velocity*dt  #agregar el Scaler

class Espacio():
    def __init__(self, target, target_error, n_particles):
        self.target = target
        self.target_error = target_error
        self.n_particles = n_particles
        self.particles = []
        self.gBest_value = float('inf')
        self.gBest_position = np.array([rd.random() * 50, rd.random() * 50])
            
    def fitness(self, particle):
        x = particle.position[0]
        y = particle.position[1]
        #f =  x**2 + y**2 + 1
        #f = pow(x, 2) + pow(y, 2)                       #Sphere
        f = pow(x*x + y -11,2) + pow(x + y*y -7,2)      #Himmelblau
        return f
    
    def set_pBest(self):
        for particle in self.particles:
            fitness_candidate = self.fitness(particle)
            if(particle.pBest_value > fitness_candidate):
                particle.pBest_value = fitness_candidate
                particle.pBest_position = particle.position

    def set_gBest(self):
        for particle in self.particles:
            best_fitness_candidate = self.fitness(particle)
            if(self.gBest_value > best_fitness_candidate):
                self.gBest_value = best_fitness_candidate
                self.gBest_position = particle.position
                
    def update_particles(self):
        for particle in self.particles:
            global W
            inertial = W * particle.velocity
            self_confidence = c1 * rd.random() * (particle.pBest_position - particle.position)
            swarm_confidence = c2 * rd.random() * (self.gBest_position - particle.position)
            new_velocity = inertial + self_confidence + swarm_confidence
            particle.velocity = new_velocity
            particle.update()
            
    def show_particles(self, iteration):        
        print(iteration, 'iterations')
        print('BestPosition in this time:', self.gBest_position)
        print('BestValue in this time:', self.gBest_value)
        
        for particle in self.particles:
            plt.plot(particle.position[0], particle.position[1], 'ro')
        plt.plot(self.gBest_position[0], self.gBest_position[1], 'bo')
        plt.suptitle("Himmelblau: 100 agentes", 
          fontdict={'family': 'serif', 
                    'color' : 'darkblue',
                    'weight': 'bold',
                    'size': 16})
        plt.title("Global best: [-2.80511809  3.13131252]")
        plt.show()

search_space = Espacio(1, target_error, n_particles)
particle_vector = [Particula() for _ in range(search_space.n_particles)]
search_space.particles = particle_vector

iteration = 0
while(iteration < n_iterations):
    # set particle best & global best
    search_space.set_pBest()
    search_space.set_gBest()

    # check conditional
    if(abs(search_space.gBest_value - search_space.target) <= search_space.target_error):
        break
        
    search_space.update_particles()
    iteration += 1
    
print("The best solution is: ", search_space.gBest_position, " in ", iteration, " iterations")
# visualization
search_space.show_particles(iteration)
